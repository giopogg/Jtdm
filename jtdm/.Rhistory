lapply(pred.array,
FUN = function(x) x$predictions.bin))
}
}
} # End loop on species
j=1
class(sp.prediction[[j]])
dim(sp.prediction[[j]]$predictions.bin)
class(sp.prediction[[j]]$predictions.bin)
aa = sp.prediction[[j]]$predictions.bin
aa = NULL
# if binary.resp=FALSE, remove the binary predictions that were eventually needed for computations if !prob.cov
if(!binary.resp & !prob.cov){
for(j in 1:length(sp.prediction)){
sp.prediction[[j]]$predictions.bin = NULL
}
}
fullPost
#predictions.bin
if(binary.resp){# Give the median
for(j in 1:length(sp.prediction)){
sp.prediction[[j]]$predictions.bin = apply(sp.prediction[[j]]$predictions.bin, 1, quantile, 0.975)
}
}
# predictions.prob
for(j in 1:length(sp.prediction)){
predictions.mean = rowMeans(sp.prediction[[j]]$predictions.prob)
predictions.q975 = apply(sp.prediction[[j]]$predictions.prob, 1, quantile, 0.975)
predictions.q025 = apply(sp.prediction[[j]]$predictions.prob, 1, quantile, 0.025)
sp.prediction[[j]]$predictions.prob = list(predictions.mean = predictions.mean,
predictions.q025 = predictions.q025,
predictions.q975 = predictions.q975
)
}
# predictions.prob.unfiltered (if needed)
if(!is.null(filter.table)){
predictions.mean = rowMeans(sp.prediction[[j]]$predictions.prob.unfiltered)
predictions.q975 = apply(sp.prediction[[j]]$predictions.prob.unfiltered,1,quantile,0.975)
predictions.q025 = apply(sp.prediction[[j]]$predictions.prob.unfiltered,1,quantile,0.025)
sp.prediction[[j]]$predictions.prob.unfiltered = list(predictions.mean = predictions.mean,
predictions.q025 = predictions.q025,
predictions.q975 = predictions.q975
)
}
for(j in list.files("~/Documents/GitHub/trophicSDM/trophicSDM/R")) {
source(paste0("~/Documents/GitHub/trophicSDM/trophicSDM/R/",j))
}
aa = predict(m_stan)
aa$sp.prediction$Y1
names(aa$sp.prediction$Y1)
binary.resp = T
aa = predict(m_stan, binary.resp = T, prob.cov = F)
names(aa$sp.prediction$Y1)
dim(aa$sp.prediction$Y1$predictions.bin)
aa = predict(m_stan, binary.resp = T, prob.cov = F, fullPost = F)
aa$sp.prediction$Y1$predictions.prob
for(j in list.files("~/Documents/GitHub/trophicSDM/trophicSDM/R")) {
source(paste0("~/Documents/GitHub/trophicSDM/trophicSDM/R/",j))
}
filter.table = list()
for(j in 1:ncol(Y)) filter.table[[j]] = rbinom(nrow(X),1,0.5)
names(filter.table) = colnames(Y)
aa = predict(m_stan, binary.resp = T, prob.cov = F, fullPost = F, filter.table =filter.table)
aa$Y1$predictions.bin
names(aa$Y1$predictions.prob)
aa$Y1$predictions.prob$predictions.mean
names(aa$Y1$predictions.prob.unfiltered)
dim(aa$Y1$predictions.prob.unfiltered)
!is.null(filter.table)
############################################################
# checks & errors
if(class(m) != "trophicSDMfit") stop("You must provide a trophicSDMfit object")
if(m$method=="glm" & pred_samples != 1 ){stop("glm requires pred_sample  = 1")}
if(is.null(Xnew)) Xnew = m$data$X
# checks for filter.table ( must be a list where each element is of length nrow(Xnew))
if(!is.null(filter.table) &
(!all(unlist(lapply(filter.table,function(x) length(x) == nrow(Xnew) ))) |
length(filter.table) != ncol(Y))) {
stop("filter.table must be a list where each element is of length nrow(Xnew) ")
}
family = m$family
n = nrow(Xnew)
S = ncol(m$data$Y)
G = m$G
mode = m$mode
# Sort species
sp.prediction = as.list(vector(length=vcount(G)))
if(mode=="prey"){
sortedV = V(G)[order(unlist(lapply(decompose(G), compute_TL_laplacian)), decreasing=T)]
}else{
sortedV = V(G)[order(unlist(lapply(decompose(G), compute_TL_laplacian)), decreasing=F)]
}
names(sp.prediction) = sortedV$name
Neighb = lapply(sortedV, function(sV) neighbors(G, sV, ifelse(mode == "prey", "out", "in")))
# core loop on species (as in trophicSDM)
for(j in 1:vcount(G)){
# print (if verbose)
if(verbose){
print(paste("--- Species", names(sortedV[j]), "---"));
print(m$model[[names(sortedV[j])]]$formula)
}
# neighbor species (hat have already been predicted)
neighb.sp = Neighb[[sortedV$name[j]]]
# create data to predict with a call to predict.SDMfit
newdata = array(data = NA, dim = c(n, (ncol(Xnew)+length(neighb.sp)), pred_samples))
colnames(newdata) = c(colnames(Xnew), names(neighb.sp))
# fill the abiotic variables
newdata[,1:ncol(Xnew),] = as.matrix(Xnew)
#### fill the biotic part of new data
## species that have already been predicted
if (length(neighb.sp)>0){ for(k in 1:length(neighb.sp)){
if(prob.cov){
# if prob.cov=TRUE, use the species predicted probabilities of presence
newdata[, ncol(Xnew)+k,] = sp.prediction[[names(neighb.sp[k])]]$predictions.prob
}else{
newdata[, ncol(Xnew)+k,] = sp.prediction[[names(neighb.sp[k])]]$predictions.bin
}
}
}
# apply the function SDMpredict to each layer of the array (MARGIN=3)
if(run.parallel){
pred.array = mclapply(1:dim(newdata)[3],
FUN = function(x){
predict.SDMfit(SDMfit = m$model[[names(sortedV[j])]],
newdata = newdata[,,x],
pred_samples=1,
binary.resp=binary.resp,
prob.cov=prob.cov)},
mc.cores = detectCores()-1)
}else{
pred.array = apply(newdata,
MARGIN = 3,
FUN = function(x){
predict.SDMfit(SDMfit = m$model[[names(sortedV[j])]],
newdata = x,
pred_samples = 1,
binary.resp = binary.resp,
prob.cov = prob.cov)})
}
# unlist and format
sp.prediction[[names(sortedV[j])]] = list()
sp.prediction[[names(sortedV[j])]]$predictions.prob =
do.call(cbind,
lapply(pred.array,
FUN=function(x) x$predictions.prob))
if(!is.null(filter.table)){
sp.prediction[[names(sortedV[j])]]$predictions.prob.unfiltered =
sp.prediction[[names(sortedV[j])]]$predictions.prob
sp.prediction[[names(sortedV[j])]]$predictions.prob =
filter.table[[names(sortedV[j])]] * do.call(cbind,
lapply(pred.array,
FUN=function(x) x$predictions.prob))
}
if(!prob.cov | binary.resp){# Here we don't care to give back $predictions.bin.unfiltered
if(!is.null(filter.table)){
sp.prediction[[names(sortedV[j])]]$predictions.bin =
filter.table[[names(sortedV[j])]] *
do.call(cbind,
lapply(pred.array,
FUN=function(x) x$predictions.bin))
}else{
sp.prediction[[names(sortedV[j])]]$predictions.bin =
do.call(cbind,
lapply(pred.array,
FUN = function(x) x$predictions.bin))
}
}
} # End loop on species
# if binary.resp=FALSE, remove the binary predictions that were eventually needed for computations if !prob.cov
if(!binary.resp & !prob.cov){
for(j in 1:length(sp.prediction)){
sp.prediction[[j]]$predictions.bin = NULL
}
}
#predictions.bin
if(binary.resp){# Give the median
for(j in 1:length(sp.prediction)){
sp.prediction[[j]]$predictions.bin = apply(sp.prediction[[j]]$predictions.bin, 1, quantile, 0.975)
}
}
# predictions.prob
for(j in 1:length(sp.prediction)){
predictions.mean = rowMeans(sp.prediction[[j]]$predictions.prob)
predictions.q975 = apply(sp.prediction[[j]]$predictions.prob, 1, quantile, 0.975)
predictions.q025 = apply(sp.prediction[[j]]$predictions.prob, 1, quantile, 0.025)
sp.prediction[[j]]$predictions.prob = list(predictions.mean = predictions.mean,
predictions.q025 = predictions.q025,
predictions.q975 = predictions.q975
)
}
# predictions.prob.unfiltered (if needed)
if(!is.null(filter.table)){
predictions.mean = rowMeans(sp.prediction[[j]]$predictions.prob.unfiltered)
predictions.q975 = apply(sp.prediction[[j]]$predictions.prob.unfiltered,1,quantile,0.975)
predictions.q025 = apply(sp.prediction[[j]]$predictions.prob.unfiltered,1,quantile,0.025)
sp.prediction[[j]]$predictions.prob.unfiltered = list(predictions.mean = predictions.mean,
predictions.q025 = predictions.q025,
predictions.q975 = predictions.q975
)
}
source("~/Documents/GitHub/trophicSDM/trophicSDM/R/trophicSDM_predict.R", echo=TRUE)
aa = predict(m_stan, binary.resp = T, prob.cov = F, fullPost = F, filter.table =filter.table)
names(aa$Y1$predictions.prob.unfiltered)
aa$Y1$predictions.prob.unfiltered$predictions.mean
aa$Y1$predictions.prob$predictions.mean
filter.table[[1]]
load("~/Desktop/SimulData.RData")
for(j in list.files("~/Documents/GitHub/trophicSDM/trophicSDM/R")) {
source(paste0("~/Documents/GitHub/trophicSDM/trophicSDM/R/",j))
}
env.formula = env.form
penal = NULL
method = "stan_glm"
library(rstanarm)
load("~/Desktop/SimulData.RData")
for(j in list.files("~/Documents/GitHub/trophicSDM/trophicSDM/R")) {
source(paste0("~/Documents/GitHub/trophicSDM/trophicSDM/R/",j))
}
env.formula = env.form
penal = NULL
method = "stan_glm"
family = binomial(link = "logit")
iter = 100
chains = 2
run.parallel = F
sp.formula = NULL
mode = "prey"
sp.partition = NULL
verbose=F
m_stan = trophicSDM(Y = Y, X = X, G = G, env.formula = env.form,
penal = NULL, method = "stan_glm", family = binomial(link = "logit"),
iter = 1000, run.parallel = F)
library(dplyr)
library(rstan)
library(rstanarm)
library(arm)
library(glmnet)
library(formula.tools)
library(abind)
library(brms)
library(stringr)
class(m_stan)
m = m_stan
Xnew = NULL
binary.resp = T
prob.cov = F
pred_samples = 1000
run.parallel = T
verbose = F
filter.table = list()
for(j in 1:ncol(Y)) filter.table[[j]] = rbinom(nrow(X),1,0.5)
names(filter.table) = colnames(Y)
fullPost = T
library(trocSDM)
env.formula = as.list(rep("~ X_1 + X_2", ncol(Y)))
env.formula = list(c("~ X_1 + X_2"),c("~ X_1 + X_2"),c("~ X_1 + X_1^2"),
c("~ X_1"), c("~ X_1 + I(X_2)^2"), c("~ X_1:X_2"))
data(Y)
data(X)
data(G)
env.formula = as.list(rep("~ X_1 + X_2", ncol(Y)))
env.formula = list(c("~ X_1 + X_2"),c("~ X_1 + X_2"),c("~ X_1 + X_1^2"),
c("~ X_1"), c("~ X_1 + I(X_2)^2"), c("~ X_1:X_2"))
tSDM = trophicSDM(Y = Y, X = X, G = G, env.formula = env.formula, sp.formula = NULL,
sp.partition = NULL,
penal = NULL, method = "stan_glm", family = binomial(link = "logit"),
iter = 100, chains = 2, run.parallel = F, verbose=F)
env.formula
names(env.formula) = colnames(Y)
tSDM = trophicSDM(Y = Y, X = X, G = G, env.formula = env.formula, sp.formula = NULL,
sp.partition = NULL,
penal = NULL, method = "stan_glm", family = binomial(link = "logit"),
iter = 100, chains = 2, run.parallel = F, verbose=F)
mcmc_rhat(tSDM$mcmc.diag$rhat)
library(bayesplot)
mcmc_rhat(tSDM$mcmc.diag$rhat)
mcmc_neff(tSDM$mcmc.diag$neff.ratio)
evaluateModelFit(tSDM)
if(tSDM$model.call$method == "glm") pred_samples =1
if(tSDM$model.call$method == "stan_glm") pred_samples = tSDM$model.call$iter/10
Ypredicted = predict(object = tSDM, pred_samples = pred_samples, fullPost = F)
Ypredicted
if(tSDM$model.call$family$family == "binomial"){
if(tSDM$model.call$method == "glm") {
Ypredicted = do.call(cbind, Ypredicted)
}
if(tSDM$model.call$method == "stan_glm"){
Ypredicted = do.call(cbind, lapply(Ypredicted, function(x) x$predictions.mean))
}
}
if(tSDM$model.call$family$family == "gaussian"){
if(tSDM$model.call$method == "glm") {
Ypredicted = do.call(cbind, lapply(Ypredicted))
}
if(tSDM$model.call$method == "stan_glm"){
Ypredicted = do.call(cbind, lapply(Ypredicted, function(x) x$predictions.mean))
}
}
Ypredicted = Ypredicted[,colnames(Ynew)]
if(!all(colnames(Ypredicted) %in% tSDM$data$sp.name) | !all(colnames(Ynew) %in% tSDM$data$sp.name)){
stop("colnames of Ynew and Ypredicted must be the same of tSDM$data$sp.name)")
}
Ynew = tSDM$data$Y
if(!all(colnames(Ypredicted) %in% tSDM$data$sp.name) | !all(colnames(Ynew) %in% tSDM$data$sp.name)){
stop("colnames of Ynew and Ypredicted must be the same of tSDM$data$sp.name)")
}
if(!all(colnames(Ypredicted) == colnames(Ynew))){
stop("colnames of Ynew and Ypredicted must coincide")
}
colnames(Ypredicted)
colnames(Ynew)
Ypredicted = Ypredicted[,colnames(Ynew)]
if(!all(colnames(Ypredicted) == colnames(Ynew))){
stop("colnames of Ynew and Ypredicted must coincide")
}
S = tSDM$data$S
# Compute Joint TSS and AUC
if(tSDM$model.call$family$family == "binomial"){
auc = tss = vector(length = S)
eval = mclapply(1:S,function(x){
eval = dismo::evaluate(p = Ypredicted[which(Ynew[,colnames(Ypredicted)[x]]==1),x],
a = Ypredicted[which(Ynew[,colnames(Ypredicted)[x]]==0),x] )
data.frame(auc = eval@auc, tss = max(eval@TPR+eval@TNR-1))
})
metrics = do.call(rbind,eval)
metrics$species = tSDM$data$sp.name
}
library(parallel)
# Compute Joint TSS and AUC
if(tSDM$model.call$family$family == "binomial"){
auc = tss = vector(length = S)
eval = mclapply(1:S,function(x){
eval = dismo::evaluate(p = Ypredicted[which(Ynew[,colnames(Ypredicted)[x]]==1),x],
a = Ypredicted[which(Ynew[,colnames(Ypredicted)[x]]==0),x] )
data.frame(auc = eval@auc, tss = max(eval@TPR+eval@TNR-1))
})
metrics = do.call(rbind,eval)
metrics$species = tSDM$data$sp.name
}
x=1
eval = dismo::evaluate(p = Ypredicted[which(Ynew[,colnames(Ypredicted)[x]]==1),x],
a = Ypredicted[which(Ynew[,colnames(Ypredicted)[x]]==0),x] )
library(terra)
install.packages(terra)
install.packages("terra")
install.packages("terra")
install.packages("terra")
install.packages("terra")
install.packages("terra")
library(terra)
library(trocSDM)
data(Y)
data(X)
data(G)
env.formula = as.list(rep("~ X_1 + X_2", ncol(Y)))
env.formula = list(c("~ X_1 + X_2"),c("~ X_1 + X_2"),c("~ X_1 + X_1^2"),
c("~ X_1"), c("~ X_1 + I(X_2)^2"), c("~ X_1:X_2"))
names(env.formula) = colnames(Y)
sp.formula = list()
for(j in 1:ncol(Y)){
if(length(names(neighbors(G,colnames(Y)[j],mode="out")))>0){
sp.formula[[j]] = paste(paste0("X_1*",names(neighbors(G,colnames(Y)[j],mode="out"))),collapse = "+")
}
}
names(sp.formula) = colnames(Y)
library(igraph)
sp.formula = list()
for(j in 1:ncol(Y)){
if(length(names(neighbors(G,colnames(Y)[j],mode="out")))>0){
sp.formula[[j]] = paste(paste0("X_1*",names(neighbors(G,colnames(Y)[j],mode="out"))),collapse = "+")
}
}
names(sp.formula) = colnames(Y)
tSDM = trophicSDM(Y = Y, X = X, G = G, env.formula = env.formula, sp.formula = sp.formula,
sp.partition = NULL,
penal = NULL, method = "stan_glm", family = binomial(link = "logit"),
iter = 100, chains = 2, run.parallel = F, verbose=F)
evaluateModelFit(tSDM)
plotG(tSDM)
plotG_inferred(tSDM)
computeVariableImportance(tSDM)
computeVariableImportance(tSDM, groups =list("X" = c("X_1","X_2"), "Y1" = c("Y1","Y2","Y3"), "Y2"= c("Y4", "Y5", "Y6")))
aa = predictFundamental(tSDM, fullPost =T)
?predict.trophicSDMfit
filter.table
filter.table = list()
for(j in 1:ncol(Y)) filter.table[[j]] = rbinom(nrow(X),1,0.5)
names(filter.table) = colnames(Y)
aa = predict(tSDM, prob.cov = F, filter.table = filter.table)
loo(trophicSDM
)
loo(trophicSDM)
?loo.trophicSDMfit
loo.trophicSDMfit(trophicSDM)
trocSDM::loo.trophicSDMfit(trophicSDM)
loo(trophicSDM)
loo()
?loo
?loo.trophicSDMfit
loo.trophicSDMfit(trophicSDM)
loo.trophicSDMfit(tSDM)
loo(tSDM)
plot(tSDM)
tSDM
summary(tSDM)
summary(tSDM)
# Check for every combinations. i.e. method = "glm"& penal = NULL/horshoe or
# method = "stan_glm", penal = NULL/horshoe/coeff.signs()
SDM = tSDM$model$Y6
class(SDM)
SDM$coef
coef(SDM)
plot(SDM)
coef(SDM, standardise = T)
summary(tSDM)
summary(SDM)
SDM
?loo
?loo.trophicSDMfit
loo(tSDM)
library(rstanarm)
?loo.trophicSDMfit
loo(tSDM)
loo.trophicSDMfit(tSDM)
library(devtools)
library(roxygen2)
library(usethis)
rm(list=ls())
setwd("~/Documents/GitHub/jtdm")
devtools::check(vignettes = T)
?eigen
?atan
?as.mcmc
?model.frame
?mvrnorm
?RMSE
rm(list=ls())
setwd("~/Documents/GitHub/jtdm")
devtools::check(vignettes = T)
devtools::check(vignettes = T)
devtools::check(vignettes = T)
?mean
rm(list=ls())
setwd("~/Documents/GitHub/jtdm")
devtools::check(vignettes = T)
?pmvnorm
devtools::check(vignettes = T)
?geom_ellipse
?bayesglm
?globalVariables
setwd("~/Documents/GitHub/jtdm")
devtools::check(vignettes = T)
setwd("~/Documents/GitHub/jtdm")
devtools::check(vignettes = T)
?coef.arm
rm(list=ls())
setwd("~/Documents/GitHub/jtdm")
devtools::check(vignettes = T)
setwd("~/Documents/GitHub/Jtdm/jtdm")
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
devtools::check(vignettes = T)
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
devtools::check(vignettes = T)
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
devtools::check(vignettes = T)
rm(list=ls())
devtools::check(vignettes = T)
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
devtools::check(vignettes = T)
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
devtools::check(vignettes = T)
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
devtools::check(vignettes = T)
usethis::use_vignette("Alpine_grasslands")
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
usethis::use_vignette("Alpine_grasslands")
devtools::build_rmd()
devtools::build_rmd("Alpine_grasslands")
devtools::build_rmd("vignettes/Alpine_grasslands")
# To build the vignette
#usethis::use_vignette("Alpine_grasslands")
#devtools::build_rmd("vignettes/Alpine_grasslands.Rmd")
devtools::check(vignettes = T)
# To build the vignette
#usethis::use_vignette("Alpine_grasslands")
devtools::build_rmd("vignettes/Alpine_grasslands.Rmd")
# To build the vignette
#usethis::use_vignette("Alpine_grasslands")
devtools::build_rmd("vignettes/Alpine_grasslands.Rmd")
library(devtools)
install_github("giopogg/Jtdm/jtdm")
rm(list=ls())
setwd("~/Documents/GitHub/Jtdm/jtdm")
# To build the vignette
#usethis::use_vignette("Alpine_grasslands")
devtools::build_rmd("vignettes/Alpine_grasslands.Rmd")
devtools::check(vignettes = T)
setwd("~/Documents/GitHub/Jtdm/jtdm")
document()
setwd("~/Documents/GitHub/Jtdm/jtdm")
document()
# To build the vignette
#usethis::use_vignette("Alpine_grasslands")
#devtools::build_rmd("vignettes/Alpine_grasslands.Rmd")
devtools::check(vignettes = T)
